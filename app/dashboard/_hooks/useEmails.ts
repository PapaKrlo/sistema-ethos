import { useState, useEffect, useCallback, useRef } from 'react';

// Cola de actualizaciones pendientes para evitar condiciones de carrera
interface UpdateQueueItem {
  emailId: string;
  updates: Partial<Email>;
  timestamp: number;
}

// Definir tipos
export interface Email {
  id: string;
  documentId?: string;
  emailId: string;
  from: string;
  subject: string;
  receivedDate: string;
  status: "necesitaAtencion" | "informativo" | "respondido";
  lastResponseBy?: "cliente" | "admin" | null;
  preview: string;
}

interface EmailResponse {
  emails: Email[];
  stats: {
    necesitaAtencion: number;
    informativo: number;
    respondido: number;
  };
}

interface UseEmailsOptions {
  refreshInterval?: number | undefined; // tiempo en ms para refresco autom√°tico, undefined para desactivar
  shouldFetchOnMount?: boolean; // si deber√≠a hacer fetch autom√°ticamente al montar
  revalidateOnFocus?: boolean; // si deber√≠a revalidar cuando la ventana recupera el foco
  dedupingInterval?: number; // intervalo para evitar peticiones duplicadas
}

export function useEmails(options: UseEmailsOptions = {}) {
  const { 
    shouldFetchOnMount = true,
    refreshInterval = undefined,
    revalidateOnFocus = false, 
  } = options;
  
  // Estados para los emails y estad√≠sticas
  const [data, setData] = useState<EmailResponse | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  
  // Referencia para controlar peticiones en vuelo
  const fetchInProgressRef = useRef(false);
  const lastFetchTimeRef = useRef<number>(0);
  const minFetchIntervalMs = 10000; // M√≠nimo 10 segundos entre peticiones (aumentado de 5 segundos)
  const debounceUpdateMs = 50; // Esperar 50ms antes de aplicar actualizaciones para agruparlas
  
  // Referencia para la cola de actualizaciones
  const updateQueueRef = useRef<UpdateQueueItem[]>([]);
  
  // Cargar la cola de actualizaciones desde localStorage al iniciar
  useEffect(() => {
    if (typeof window !== 'undefined') {
      try {
        const savedQueue = localStorage.getItem('emailUpdateQueue');
        if (savedQueue) {
          const parsedQueue = JSON.parse(savedQueue) as UpdateQueueItem[];
          
          // Solo restaurar las actualizaciones si son v√°lidas
          if (Array.isArray(parsedQueue) && parsedQueue.length > 0) {
            console.log(`üìÇ Cargados ${parsedQueue.length} elementos de la cola desde localStorage`);
            updateQueueRef.current = parsedQueue;
          }
        }
      } catch (error) {
        console.error('Error al cargar cola desde localStorage:', error);
      }
    }
  }, []);
  
  // Funci√≥n para obtener emails del servidor
  const fetchEmails = useCallback(async (refresh = false) => {
    // Log para debuggear las llamadas a fetchEmails
    console.log(`üì© fetchEmails llamado con refresh=${refresh}. Actualizaciones pendientes: ${updateQueueRef.current.length}`);
    
    // Evitar m√∫ltiples peticiones simult√°neas
    if (fetchInProgressRef.current) {
      console.log("‚ö†Ô∏è fetchEmails: Ya hay una petici√≥n en curso, ignorando");
      return;
    }
    
    // Comprobar frecuencia m√≠nima entre peticiones
    const now = Date.now();
    const timeSinceLastFetch = now - lastFetchTimeRef.current;
    if (timeSinceLastFetch < minFetchIntervalMs) {
      console.log(`‚è±Ô∏è fetchEmails: Demasiadas peticiones. Espera ${Math.ceil((minFetchIntervalMs - timeSinceLastFetch) / 1000)} segundos.`);
      return;
    }
    
    // Marcar inicio de petici√≥n y actualizar tiempo
    fetchInProgressRef.current = true;
    lastFetchTimeRef.current = now;
    
    const url = refresh ? '/api/emails/fetch?refresh=true' : '/api/emails/fetch';
    const maxRetries = 2; // N√∫mero m√°ximo de reintentos
    let retryCount = 0;
    
    const attemptFetch = async () => {
      try {
        const isInitialFetch = !data;
        if (isInitialFetch) {
          setIsLoading(true);
        } else {
          setIsRefreshing(true);
        }
        
        // Intentar usar la API con cach√© primero
        const response = await fetch('/api/emails/fetch', {
          cache: 'no-store',  // Asegurar que no usamos cach√© del navegador
          headers: {
            'x-no-auto-refetch': 'true' // Indicar al servidor que esta es una petici√≥n manual
          }
        });
        
        if (!response.ok) {
          // Si es un error y se solicit√≥ refresh, intentar con refresh expl√≠cito
          if (refresh) {
            console.log("Intentando con par√°metro refresh expl√≠cito");
            const refreshResponse = await fetch('/api/emails/fetch?refresh=true', {
              cache: 'no-store',
              headers: {
                'x-no-auto-refetch': 'true'
              }
            });
            
            if (refreshResponse.ok) {
              const responseData = await refreshResponse.json();
              setData(responseData);
              setError(null);
              return;
            }
          }
          
          // Si es un 404, intentar usar datos en cach√© si est√°n disponibles
          if (response.status === 404 && data) {
            console.log("Error 404, utilizando datos en cach√©");
            // No actualizamos los datos pero tampoco mostramos error al usuario
            return;
          }
          
          throw new Error(`Error: ${response.status} ${response.statusText}`);
        }
        
        const responseData = await response.json();
        
        if (responseData.error) {
          throw new Error(responseData.error);
        }
        
        // Evitar actualizaciones si no hay cambios reales
        const hasChanges = !data || 
          JSON.stringify(data.stats) !== JSON.stringify(responseData.stats) ||
          data.emails.length !== responseData.emails.length;
          
        if (hasChanges) {
          console.log("üìä Se detectaron cambios en los datos, actualizando estado");
          setData(responseData);
        } else {
          console.log("üîÑ No hay cambios significativos en los datos, evitando re-render");
        }
        
        setError(null);
      } catch (err: any) {
        console.error(`Error al obtener emails (intento ${retryCount + 1}/${maxRetries + 1}):`, err);
        
        // Si a√∫n no hemos alcanzado el m√°ximo de reintentos, intentamos de nuevo
        if (retryCount < maxRetries) {
          retryCount++;
          console.log(`Reintentando conexi√≥n (${retryCount}/${maxRetries})...`);
          await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar 1 segundo antes de reintentar
          return attemptFetch(); // Llamada recursiva
        }
        
        // Si ya agotamos los reintentos, propagamos el error
        // Pero si tenemos datos previos, seguimos us√°ndolos
        if (data) {
          console.log("Usando datos en cach√© tras error persistente");
          // Mostrar notificaci√≥n de error al usuario
          if (typeof window !== 'undefined') {
            const event = new CustomEvent('showNotification', {
              detail: {
                type: 'warning',
                title: 'Advertencia',
                message: 'No se pudieron obtener correos nuevos. Usando datos en cach√©.'
              }
            });
            window.dispatchEvent(event);
          }
        } else {
          setError(err);
        }
      } finally {
        setIsLoading(false);
        setIsRefreshing(false);
        // Marcar fin de petici√≥n
        fetchInProgressRef.current = false;
      }
    };
    
    await attemptFetch();
  }, [data]);
  
  // Cargar emails al montar el componente (solo una vez)
  useEffect(() => {
    if (shouldFetchOnMount) {
      fetchEmails();
    }
    
    // Funci√≥n de limpieza que se ejecuta al desmontar
    return () => {
      // Limpiar cualquier petici√≥n pendiente
      fetchInProgressRef.current = false;
    };
  }, [shouldFetchOnMount, fetchEmails]);
  
  // Configurar refresco autom√°tico si est√° habilitado (desactivado por defecto)
  useEffect(() => {
    // Deshabilitamos esta caracter√≠stica para evitar el bucle de refetches
    if (refreshInterval && refreshInterval > 0) {
      console.log(`‚è±Ô∏è Configurando refresco autom√°tico cada ${refreshInterval / 1000} segundos`);
      
      const intervalId = setInterval(() => {
        if (!fetchInProgressRef.current) {
          console.log("üîÑ Refrescando autom√°ticamente emails...");
          fetchEmails(true);
        } else {
          console.log("‚ö†Ô∏è Omitiendo refresco autom√°tico porque hay una petici√≥n en curso");
        }
      }, refreshInterval);
      
      return () => {
        console.log("üõë Limpiando intervalo de refresco autom√°tico");
        clearInterval(intervalId);
      };
    }
    
    return undefined;
  }, [refreshInterval, fetchEmails]);
  
  // Configurar revalidaci√≥n al enfocar la ventana (desactivado por defecto)
  useEffect(() => {
    if (!revalidateOnFocus) return undefined;
    
    const handleFocus = () => {
      // Solo revalidar si ha pasado al menos minFetchIntervalMs desde la √∫ltima petici√≥n
      const now = Date.now();
      if (now - lastFetchTimeRef.current >= minFetchIntervalMs && !fetchInProgressRef.current) {
        console.log("üëÅÔ∏è La ventana recibi√≥ foco, refrescando emails...");
        fetchEmails(true);
      } else {
        console.log("‚ö†Ô∏è Omitiendo refresco por foco debido a tiempo m√≠nimo o petici√≥n en curso");
      }
    };
    
    console.log("üëÅÔ∏è Configurando revalidaci√≥n al enfocar la ventana");
    window.addEventListener('focus', handleFocus);
    
    return () => {
      console.log("üõë Limpiando evento de foco");
      window.removeEventListener('focus', handleFocus);
    };
  }, [revalidateOnFocus, fetchEmails, minFetchIntervalMs]);
  
  // Funci√≥n para forzar una actualizaci√≥n (refresh) con datos nuevos del servidor
  const refreshEmails = async () => {
    try {
      // Log para debuggear
      console.log(`üîÑ refreshEmails llamado. Ruta: ${new Error().stack}`);
      
      // Evitar m√∫ltiples peticiones simult√°neas
      if (fetchInProgressRef.current) {
        console.log("‚ö†Ô∏è refreshEmails: Ya hay una petici√≥n en curso. Ignorando solicitud de refresh.");
        // Mostrar notificaci√≥n al usuario
        if (typeof window !== 'undefined') {
          const event = new CustomEvent('showNotification', {
            detail: {
              type: 'info',
              title: 'Informaci√≥n',
              message: 'Actualizaci√≥n en progreso, espere un momento'
            }
          });
          window.dispatchEvent(event);
        }
        return data;
      }
      
      // Verificar tiempo m√≠nimo entre peticiones
      const now = Date.now();
      const timeSinceLastFetch = now - lastFetchTimeRef.current;
      if (timeSinceLastFetch < minFetchIntervalMs) {
        console.log(`‚è±Ô∏è refreshEmails: Demasiado pronto para refrescar. Espere ${Math.ceil((minFetchIntervalMs - timeSinceLastFetch) / 1000)} segundos.`);
        // Mostrar notificaci√≥n al usuario
        if (typeof window !== 'undefined') {
          const event = new CustomEvent('showNotification', {
            detail: {
              type: 'info',
              title: 'Informaci√≥n',
              message: `Refrescando demasiado r√°pido, espere ${Math.ceil((minFetchIntervalMs - timeSinceLastFetch) / 1000)} segundos`
            }
          });
          window.dispatchEvent(event);
        }
        return data;
      }
      
      // Forzar un refresh expl√≠cito
      console.log("üîÑ Iniciando refetch manual forzado");
      await fetchEmails(true);
      
      // Mostrar notificaci√≥n de √©xito si todo sali√≥ bien
      if (typeof window !== 'undefined') {
        const event = new CustomEvent('showNotification', {
          detail: {
            type: 'success',
            title: 'Actualizaci√≥n completada',
            message: 'Los correos se han actualizado correctamente'
          }
        });
        window.dispatchEvent(event);
      }
      return data;
    } catch (err: any) {
      console.error("Error al refrescar emails:", err);
      // Mostrar notificaci√≥n de error al usuario
      if (typeof window !== 'undefined') {
        const event = new CustomEvent('showNotification', {
          detail: {
            type: 'error',
            title: 'Error',
            message: 'No se pudieron actualizar los correos'
          }
        });
        window.dispatchEvent(event);
      }
      throw err;
    }
  };
  
  // Funci√≥n para actualizar localmente un email espec√≠fico (sin hacer fetch)
  const updateEmail = useCallback((emailId: string, updates: Partial<Email>) => {
    console.log(`üìù Agregando actualizaci√≥n a la cola: ${emailId} ‚Üí ${JSON.stringify(updates)}`);
    
    // Verificar si ya existe una actualizaci√≥n para este correo en la cola
    const existingUpdateIndex = updateQueueRef.current.findIndex(item => item.emailId === emailId);
    
    // Crear el nuevo item de actualizaci√≥n
    const queueItem: UpdateQueueItem = {
      emailId,
      updates,
      timestamp: Date.now()
    };
    
    // Si ya existe, reemplazarlo; si no, a√±adirlo
    if (existingUpdateIndex !== -1) {
      // Combinar las actualizaciones (la nueva prevalece)
      const existingUpdates = updateQueueRef.current[existingUpdateIndex].updates;
      queueItem.updates = { ...existingUpdates, ...updates };
      updateQueueRef.current[existingUpdateIndex] = queueItem;
      console.log(`üîÑ Actualizada entrada existente en la cola para ${emailId}`);
    } else {
      // A√±adir nuevo item a la cola
      updateQueueRef.current.push(queueItem);
      console.log(`‚ûï Nueva entrada a√±adida a la cola para ${emailId}`);
    }
    
    // Guardar estado de la cola en localStorage para persistencia
    if (typeof window !== 'undefined') {
      try {
        localStorage.setItem('emailUpdateQueue', JSON.stringify(updateQueueRef.current));
        console.log(`üíæ Cola guardada en localStorage con ${updateQueueRef.current.length} elementos`);
      } catch (error) {
        console.error('Error al guardar cola en localStorage:', error);
      }
    }
    
    setData(prevData => {
      if (!prevData) return null;
      
      // Reconstruir la lista aplicando todas las actualizaciones en orden cronol√≥gico
      let updatedEmails = [...prevData.emails];
      let updatedStats = { ...prevData.stats };
      
      // Aplicar todas las actualizaciones en la cola
      updateQueueRef.current.forEach(item => {
        const { emailId, updates } = item;
        
        // Buscar el email que se va a actualizar
        const emailIndex = updatedEmails.findIndex(e => e.emailId === emailId);
        if (emailIndex === -1) return; // Email no encontrado
        
        const oldEmail = updatedEmails[emailIndex];
        
        // Crear el email actualizado
        const updatedEmail = { ...oldEmail, ...updates };
        
        // Actualizar el email en la lista
        updatedEmails[emailIndex] = updatedEmail;
        
        // Actualizar estad√≠sticas si cambi√≥ el estado
        if (updates.status && oldEmail.status !== updates.status) {
          // Reducir contador del estado anterior
          if (oldEmail.status === "necesitaAtencion") updatedStats.necesitaAtencion--;
          else if (oldEmail.status === "informativo") updatedStats.informativo--;
          else if (oldEmail.status === "respondido") updatedStats.respondido--;
          
          // Aumentar contador del nuevo estado
          if (updates.status === "necesitaAtencion") updatedStats.necesitaAtencion++;
          else if (updates.status === "informativo") updatedStats.informativo++;
          else if (updates.status === "respondido") updatedStats.respondido++;
        }
      });
      
      console.log(`üìä Estado actual de estad√≠sticas: NA=${updatedStats.necesitaAtencion}, INF=${updatedStats.informativo}, RESP=${updatedStats.respondido}`);
      
      // Retornar un nuevo objeto con los datos actualizados
      return { 
        emails: updatedEmails, 
        stats: updatedStats 
      };
    });
  }, []);
  
  // Limpiar la cola de actualizaciones cuando se reciben nuevos datos del servidor
  useEffect(() => {
    if (data) {
      // Solo aplicar esto si hay actualizaciones pendientes y si no estamos en medio de un fetch
      if (updateQueueRef.current.length > 0 && !fetchInProgressRef.current) {
        console.log(`üîÑ Reaplicando ${updateQueueRef.current.length} actualizaciones despu√©s de obtener nuevos datos`);
        
        // Usar una bandera para evitar el bucle infinito
        const pendingUpdates = [...updateQueueRef.current];
        
        // Limpiar la cola para evitar replicaciones
        // Ya hemos grabado las actualizaciones en el servidor, ahora podemos limpiar la cola
        updateQueueRef.current = [];
        
        // Actualizar el localStorage con la cola vac√≠a
        if (typeof window !== 'undefined') {
          try {
            localStorage.setItem('emailUpdateQueue', JSON.stringify(updateQueueRef.current));
            console.log(`üßπ Cola limpiada en localStorage despu√©s de aplicar actualizaciones`);
          } catch (error) {
            console.error('Error al guardar cola vac√≠a en localStorage:', error);
          }
        }
        
        // Prevenir m√∫ltiples actualizaciones r√°pidas
        setTimeout(() => {
          // Solo si no hay un fetch en progreso
          if (!fetchInProgressRef.current) {
            // Crear una √∫nica actualizaci√≥n de estado para todas las modificaciones
            setData(prevData => {
              if (!prevData) return null;
              
              // Copiar datos para modificar
              const updatedEmails = [...prevData.emails];
              const updatedStats = { ...prevData.stats };
              
              // Aplicar todas las actualizaciones pendientes de una vez
              pendingUpdates.forEach(item => {
                const { emailId, updates } = item;
                
                // Verificar si el correo a√∫n existe en los datos actualizados
                const emailIndex = updatedEmails.findIndex(e => e.emailId === emailId);
                if (emailIndex === -1) return;
                
                const oldEmail = updatedEmails[emailIndex];
                updatedEmails[emailIndex] = { ...oldEmail, ...updates };
                
                // Actualizar estad√≠sticas si cambi√≥ el estado
                if (updates.status && oldEmail.status !== updates.status) {
                  // Reducir contador del estado anterior
                  if (oldEmail.status === "necesitaAtencion") updatedStats.necesitaAtencion--;
                  else if (oldEmail.status === "informativo") updatedStats.informativo--;
                  else if (oldEmail.status === "respondido") updatedStats.respondido--;
                  
                  // Aumentar contador del nuevo estado
                  if (updates.status === "necesitaAtencion") updatedStats.necesitaAtencion++;
                  else if (updates.status === "informativo") updatedStats.informativo++;
                  else if (updates.status === "respondido") updatedStats.respondido++;
                }
              });
              
              return {
                emails: updatedEmails,
                stats: updatedStats
              };
            });
          }
        }, debounceUpdateMs);
      }
    }
  }, [data]);
  
  // Devolver un objeto con la misma interfaz que ten√≠a con SWR
  return {
    emails: data?.emails || [],
    stats: data?.stats || { necesitaAtencion: 0, informativo: 0, respondido: 0 },
    isLoading,
    isRefreshing,
    error,
    refreshEmails,
    updateEmail
  };
} 